#+TITLE: Elastica : Coordinate/Frame transformations
#+AUTHOR: /Tejaswin Parthasarathy/, Mattia Gazzola
#+SUBTITLE: ME498: Comp. modeling & optimization
#+BEAMER_FRAME_LEVEL: 2
# #+BEAMER_HEADER: \institute[INST]{Institute\\\url{http://www.institute.edu}}
# #+BEAMER_HEADER: \titlegraphic{\includegraphics[height=1.5cm]{test}}

#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
# #+LATEX_CLASS_OPTIONS: [notes]
#+LATEX_HEADER:\usetheme[progressbar=frametitle]{metropolis}
#+LATEX_HEADER:\usepackage{tikz}
#+LATEX_HEADER:\usepackage{tikz-3dplot}
#+LATEX_HEADER:\usepackage{spot}
#+LATEX_HEADER:\newcommand{\gv}[1]{\ensuremath{\mbox{\boldmath$ #1 $}}}
#+LATEX_HEADER:\newcommand{\bv}[1]{\ensuremath{\mathbf{#1}}}
#+LATEX_HEADER:\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
#+LATEX_HEADER:\newcommand{\abs}[1]{\left\lvert#1\right\rvert}
#+LATEX_HEADER:\newcommand{\bigqm}[1][1]{\text{\larger[#1]{\text{?}}}}
#+LATEX_HEADER:\newcommand{\order}[1]{\mathcal O \left( #1 \right)} % order of magnitude
#+LATEX_HEADER:\definecolor{scarlet}{rgb}{1.0, 0.13, 0.0}
#+LATEX_HEADER:\definecolor{shamrockgreen}{rgb}{0.0, 0.62, 0.38}
#+LATEX_HEADER:\definecolor{royalblue}{rgb}{0.25, 0.41, 0.88}
#+OPTIONS:   H:2 num:t toc:nil ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS:   tex:t d:nil todo:t pri:nil tags:nil
#+COLUMNS: %45ITEM %10BEAMER_ENV(Env) %10BEAMER_ACT(Act) %4BEAMER_COL(Col) %8BEAMER_OPT(Opt)
* Coordinate/Frame transformations
** Motivation
   \[ \gv{x}_{\mathcal{L}} = \bv{Q}\gv{x} \]
   #+begin_export latex
   \[ \scalebox{5}{\textbf{?}} \]
   #+end_export
   \[ \frac{\partial \bv{d}_j}{\partial t} = \left( \bv{Q}^T
   \omega_{\mathcal{L}}\right) \times \bv{d}_j \]
   #+begin_export latex
   \[ \scalebox{5}{\textbf{?}} \]
   #+end_export

** Motivation
*** Transformations used                                           :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.7
	:END:
	 - To convert between arbitrary spaces, e.g. world space and other spaces (in
       graphics) or Eulerian frame to Lagrangian frame in physics
     - To convert between coordinates that are more "natural" to the system under
       observation---e.g. complex numbers can be naturally represented in polar,
       rather than cartesian coordinates
   - Transformations can be applied to points, vectors etc.
*** Transformations used                                           :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.4
	:END:
	#+CAPTION: The complex plane, taken from Wikimedia
	#+ATTR_LATEX: :width 0.9\textwidth
	[[file:images/complex.pdf]]
** Introduction
  - Some familiar coordinate transformations (each with its own natural "frame"
    of vectors)
    are
*** Coordinates                                                    :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.4
	:END:
**** Cartesian coordinates
	 - Coordinate: \( (x, y, z) \)
	 - Frame : \( \hat{\gv{e}_x}, \hat{\gv{e}_y}, \hat{\gv{e}_z}\)
*** Pictures                                                       :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.6
	:END:
	#+CAPTION: Cartesian coordinate system, Wikimedia
	#+ATTR_LATEX: :width 0.8\textwidth
	[[file:images/cartesian.pdf]]
** Introduction
*** Cyl                                                            :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.4
	:END:
**** Cylindrical coordinates
	 - Coordinate: \( (\rho, \phi, z) \)
	 - Frame : \( \hat{\gv{e}_\rho}, \hat{\gv{e}_\phi}, \hat{\gv{e}_z}\)
	 #+CAPTION: Cylindrical coordinate system, Wikimedia
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/cylindrical.pdf]]

*** Spherical                                                      :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.4
	:END:
**** Spherical coordinates
	 - Coordinate: \( (r, \theta, \phi) \)
	 - Frame : \( \hat{\gv{e}_r}, \hat{\gv{e}_\theta}, \hat{\gv{e}_\phi}\)

	#+CAPTION: Spherical coordinate system, Wikimedia
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/spherical.pdf]]
** Introduction
*** Choice of coordinate system
	- We represent entities (points, vectors etc.) in the /cartesian coordinate
      system/, considering only Euclidean geometry
*** Why?
	- To use certain *affine* transformations
*** Affine transformations                                     :B_definition:
	:PROPERTIES:
	:BEAMER_env: definition
	:END:
	- any function between /affine spaces/ which preserves points, straight lines and planes
	- Examples: translation, scaling, similarity transformation,
      reflection, rotation, etc. and their compositions
** Affine transformations
*** Affine \leftrightarrow Linear                                 :B_theorem:
	:PROPERTIES:
	:BEAMER_env: theorem
	:END:

	If \( \mathcal{X} \) and \(\mathcal{Y}\) are affine spaces, then every affine transformation
	\(f\colon \mathcal{X}\to \mathcal{Y} \) is of the form \(\gv{x}\mapsto
	\bv{M}\gv{x}+\gv{b}\) where \(\bv{M}\) is a linear transformation on the
	space \( \mathcal{X}\),  \( \gv{x} \) is a vector in \( \mathcal{X} \), and \(
	\gv{b} \) is a vector in \( \mathcal{Y} \).

** Affine transformations : Examples
*** Translations ( \( \bv{M} = \bv{0} \) and \( \gv{b} \neq \gv{0}\) )
	#+CAPTION: Translation of entities, Wikimedia, CC4.0
	#+ATTR_LATEX: :width 0.4\textwidth
	[[file:images/translate.pdf]]
*** Translation *DEMO*
** Linear transformations
*** Difference b/w linear and affine trans.                         :B_block:
	:PROPERTIES:
	:BEAMER_env: block
	:END:
	- Most of our interest lies in modeling soft filaments, for which we will be
      using only /linear transformations/
	- In linear transformations, \( \gv{b} \equiv \gv{0} \) for vector spaces \(
      \mathcal{X} \) and \(\mathcal{Y}\)
	- We lose the ability to translate entities using linear transformations (
      zero must map to zero by definition)
** But what are linear transformations?
   - We loosely define a linear transformation \( \gv{x} \to \bv{M}\gv{x} \) by a /matrix/
     ( \( \bv{M}\) ) that acts on the vector \( \gv{x} \)
   - Check out the Wikipedia page on [[https://en.wikipedia.org/wiki/Matrix_(mathematics)][matrices]] and [[https://en.wikipedia.org/wiki/Rotation_matrix][matrix classes]] to see why they
     (matrices and linear transformations) are considered important.
** Linear transformations : Examples[fn:1]
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.5
	:END:
**** Identity
	\[ \bv{M} = \begin{bmatrix}1&0&0\\0&1&0\\0&0&1\end{bmatrix} \]
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/ch_id.pdf]]
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.5
	:END:
**** Reflection
	\[ \bv{M} =\begin{bmatrix}-1&0&0\\0&1&0\\0&0&1\end{bmatrix} \]
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/ch_ref.pdf]]

** Linear transformations : Examples
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.5
	:END:
**** Scale
	\[ \bv{M} =\begin{bmatrix}c_{x}=2&0&0\\0&c_{y}=1&0\\0&0&1\end{bmatrix} \]
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/ch_sc.pdf]]
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_COL: 0.5
	:END:
**** Shear
	\[ \bv{M} =\begin{bmatrix}1&c_{x}=0.5&0\\c_{y}=0&1&0\\0&0&1\end{bmatrix}\]
	#+ATTR_LATEX: :height 0.8\textwidth
	[[file:images/ch_sh.pdf]]

** Linear transformations : Examples
*** Rotation
	#+begin_export latex
	\begin{center}
	\spot<2>{\( \bv{M} =\begin{bmatrix}\cos(\theta )&\sin(\theta )&0\\-\sin(\theta
   )&\cos(\theta )&0\\0&0&1\end{bmatrix} \text{with } \theta = \frac{\pi}{6}\)}
	\end{center}
	#+end_export
   # \[ \bv{M} =\begin{bmatrix}\cos(\theta )&\sin(\theta )&0\\-\sin(\theta
   # )&\cos(\theta )&0\\0&0&1\end{bmatrix} \text{with } \theta = \frac{\pi}{6}\]
   #+ATTR_LATEX: :height 0.5\textwidth
	[[file:images/ch_rot.pdf]]
** Rotations (includes reflections)
   - Generates new unit vectors, fundamentally changing the directions
     (eigenvectors) of further transformations
   - Does not scale the entity under consideration ( \( \abs{\lambda} \equiv  1
     \), more on this later...)
** Frame rotations in two--dimensions
   Consider
   #+CAPTION: Rotation in two dimensions
   #+ATTR_LATEX: :width 0.45\textwidth
   file:images/cartesian_rotation.png

   \[ \begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix}
   = \underbrace{\begin{bmatrix}\cos(\alpha )&\sin(\alpha )\\ -\sin(\alpha
   )&\cos(\alpha )\end{bmatrix}}_{\bv{R}} \begin{bmatrix} x\\ y\end{bmatrix}\]
** Inverse rotations in two--dimensions
   Now consider the same picture, but we want to obtain \([x,y]^T\) from \( [
   x^\prime, y^\prime ]^T \) (the other way around).

   - Physically, this is just a rotation of \( - \alpha \) counter-clockwise (or
     \( \alpha \) clockwise). That means
   \[ \begin{bmatrix} x\\ y\end{bmatrix}
   = \begin{bmatrix}\cos(\alpha )& -\sin(\alpha )\\ \sin(\alpha
   )& \cos(\alpha )\end{bmatrix}  \begin{bmatrix} x^\prime \\ y^\prime
   \end{bmatrix} \]
   - Mathematically, if \( \gv{x}^\prime= \bv{R} \gv{x} \), then we know \(
     \gv{x}= \bv{R}^{-1} \gv{x}^\prime \), provided \( \bv{R}^{-1}\) exists
     (which does).
   - Then notice that
   \[ \bv{R}^{-1} = \begin{bmatrix}\cos(\alpha )& -\sin(\alpha )\\ \sin(\alpha
   )& \cos(\alpha )\end{bmatrix}  = \bv{R}^T ! \]
   - We will see later why holds for *all* rotation matrices...
** Frame rotations in three--dimensions
   #+CAPTION: Rotation in three dimensions, Wikimedia CC1.0
   #+ATTR_LATEX: :width 0.45\textwidth
   [[file:images/cartesian_rot_3D.pdf]]
   is a natural extension of 2D results...
** Beware!
*** Be wary about alias (passive) or alibi (active) transformations
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.55
	:END:
**** Alias transformations                                     :B_definition:
	 :PROPERTIES:
	 :BEAMER_env: definition
	 :END:
	 Involves rotation of the coordinate system or frame
	 (change in basis)
**** Alibi transformations                                           :B_definition:
	 :PROPERTIES:
	 :BEAMER_env: definition
	 :END:
	 Involves rotation of the entities within the same
	 frame (change in entity)
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.5
	:END:
   #+CAPTION: Alias-Alibi transformations, Wikimedia CC3.0
   #+ATTR_LATEX: :width 1.00\textwidth
	[[file:images/alias_alibi.png]]
***                                                         :B_ignoreheading:
	:PROPERTIES:
	:BEAMER_env: ignoreheading
	:END:
	Both are equally valid ways of representing rotations---in this class
	however, we focus on alias transformations.
***                                                                  :B_note:
	:PROPERTIES:
	:BEAMER_env: note
	:END:
	- Affirm that the entity does not matter. Show this for a vector or a point.
      Beauty of affine transformations.
	- To change the formulas for passive rotations (or find reverse active
      rotation), transpose the matrices (then each matrix transforms the initial
      coordinates of a vector remaining fixed to the coordinates of the same
      vector measured in the rotated reference system; same rotation axis, same
      angles, but now the coordinate system rotates, rather than the vector).
** Difference in perspectives[fn:2]
***                                                             :B_quotation:
	:PROPERTIES:
	:BEAMER_env: quotation
	:END:
	" Analyzing rotation demands awareness of your desired perspective. You can rotate an object, while you stay still, or you can keep the object
	fixed while you rotate yourself. It is important to be aware of which of these
	perspectives applies for your problem of interest. The distinction between
	these fundamentally different transformations goes beyond one being the
	same as the other with an opposite rotation angle. "
** TODO Frame rotation as a change in basis
*** More concretely
	If \( \mathcal{B} \) and \( \mathcal{B}^\prime \) are two (different) bases
	\( \in \mathbb{R}^n \)
	+ Alibi : Change in entity \( [\gv{p}]_{\mathcal{B}} \to
      [\gv{p}^\prime]_{\mathcal{B}} \) given by
  \[ [\gv{p}^\prime]_{\mathcal{B}} = [\bv{M}]_{\mathcal{B} \to \mathcal{B}}
  [\gv{p}]_{\mathcal{B}} \]
	+ Alias : Change in basis \( [\gv{p}]_{\mathcal{B}} \to
      [\gv{p}]_{\mathcal{B}^\prime} \)
  \[ [\gv{p}]_{\mathcal{B}^\prime} = [\bv{M}]_{\mathcal{B} \to \mathcal{B}^\prime}
  [\gv{p}]_{\mathcal{B}} \]
	+ In our soft filament framework, \( \mathcal{B}^\prime \equiv \mathcal{L}
      \) and  \( \mathcal{B} \equiv \) lab frame. \( \bv{Q} \) is then the
      basis transformation matrix (corresponding to pure rotation of the
      orthonormal bases)
** Frame rotation---example
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.5
	:END:
	 #+begin_export latex
	 \tdplotsetmaincoords{60}{100}
	 \begin{center}
		\begin{tikzpicture}[scale=2, tdplot_main_coords]
		\draw[thick,->, color=scarlet] (0,0,0) -- (1,0,0) node[anchor=north east]{$x$};
		\draw[thick,->, color=shamrockgreen] (0,0,0) -- (0,1,0) node[anchor=north west]{$y$};
		\draw[thick,->, color=royalblue] (0,0,0) -- (0,0,1) node[anchor=south]{$z$};
		\end{tikzpicture}
	 \end{center}
	 #+end_export
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.5
	:END:
	 #+begin_export latex
	 \tdplotsetmaincoords{60}{100}
	 \begin{center}
		\begin{tikzpicture}[scale=2, tdplot_main_coords]
		\draw[dashed,->,line width= 1.1pt] (0,0,0) -- (1,0,0) node[anchor=north east]{$x$};
		\draw[dashed,->,line width= 1.1pt] (0,0,0) -- (0,1,0) node[anchor=north west]{$y$};
		\draw[dashed,->,line width= 1.1pt] (0,0,0) -- (0,0,1) node[anchor=south west]{$z$};

		\coordinate (Shift) at (0,0,0);
		\tdplotsetrotatedcoords{0}{0}{90}
		\tdplotsetrotatedcoordsorigin{(Shift)}

		\draw[thick,color=scarlet,tdplot_rotated_coords,->] (0,0,0)
		-- (1,0,0) node[anchor=south east]{$x’$};
		\draw[thick,color=shamrockgreen,tdplot_rotated_coords,->] (0,0,0)
		-- (0,1,0) node[anchor=west]{$y’$};
		\draw[thick,color=royalblue,tdplot_rotated_coords,->] (0,0,0)
		-- (0,0,1) node[anchor=south east]{$z’$};
		\end{tikzpicture}
	 \end{center}
	 #+end_export
***                                                         :B_ignoreheading:
	:PROPERTIES:
	:BEAMER_env: ignoreheading
	:END:
	- Represent \( (x-y-z) \) axis with a basis \( \mathcal{E}\) of unit vectors \( \hat{\gv{e}_1}, \hat{\gv{e}_2}, \hat{\gv{e}_3}\)
	- Represent \( (x'-y'-z') \) axis with a basis \( \mathcal{D} \) of unit vectors \( \hat{\gv{d}_1}, \hat{\gv{d}_2}, \hat{\gv{d}_3}\)
	- \( \mathcal{E} \to \mathcal{D} \)?
	- Note : rotation of \( \ang{90} \) about an invariant \( z' = z \) axis
** Frame rotation---example contd.
  \[ {\begin{bmatrix} x^\prime \\ y^\prime \\ z^\prime\end{bmatrix}} =
  \spot{[\bv{M}]_{\mathcal{E} \to \mathcal{D}}}
  {\begin{bmatrix} x \\ y \\ z \end{bmatrix}}
  \]
   - We begin by noticing that \( \begin{bmatrix} x^\prime , y^\prime , z^\prime
     \end{bmatrix} = \begin{bmatrix} y , -x , z \end{bmatrix}\) (from figure). Then
  \[ {\begin{bmatrix} x^\prime \\ y^\prime \\ z^\prime\end{bmatrix}} =
  {\begin{bmatrix} 0 & 1 & 0 \\ -1 & 0 & 0 \\ 0 & 0 & 1 \end{bmatrix}}
  {\begin{bmatrix} x \\ y \\ z \end{bmatrix}}
  \]
  \[\Rightarrow {\begin{bmatrix} x^\prime \\ y^\prime \\ z^\prime\end{bmatrix}} =
  {\begin{bmatrix} \cos(\ang{90}) & \sin(\ang{90}) & 0 \\ -\sin(\ang{90}) &
  \cos(\ang{90}) & 0 \\ 0 & 0 & 1 \end{bmatrix}}
  {\begin{bmatrix} x \\ y \\ z \end{bmatrix}}
  \]
** Generalizing frame rotations as a basis change
   - But also notice with the given bases that
  \[{\begin{bmatrix} x^\prime \\ y^\prime \\ z^\prime\end{bmatrix}_{\mathcal{D}}} =
  \spot<2>{
  \underbrace{\begin{bmatrix}
  \hat{\gv{d}}_1 \cdot \hat{\gv{e}}_1 & \hat{\gv{d}}_1 \cdot
  \hat{\gv{e}}_2 & \hat{\gv{d}}_1 \cdot \hat{\gv{e}}_3 \\
  \hat{\gv{d}}_2 \cdot \hat{\gv{e}}_1 & \hat{\gv{d}}_2 \cdot
  \hat{\gv{e}}_2 & \hat{\gv{d}}_2 \cdot \hat{\gv{e}}_3 \\
  \hat{\gv{d}}_3 \cdot \hat{\gv{e}}_1 & \hat{\gv{d}}_3 \cdot
  \hat{\gv{e}}_2 & \hat{\gv{d}}_3 \cdot \hat{\gv{e}}_3
  \end{bmatrix}}_{[\bv{M}]_{\mathcal{E} \to \mathcal{D}}, \text{ independent of
  } \mathbf{x}}
  }
  {\begin{bmatrix} x \\ y \\ z \end{bmatrix}_{\mathcal{E}}}
  \]
*** Soft filament framework                                         :B_block:
	:PROPERTIES:
	:BEAMER_env: block
	:BEAMER_ACT: <2->
	:END:
   - Describe lab frame, \( \mathcal{E} \), by natural bases \(\hat{i}, \hat{j}, \hat{k} \).
   - Describe material (Lagrangian) frame, \( \mathcal{D} \), by orthonormal
     vectors \(\hat{\gv{d}_1}, \hat{\gv{d}_2}, \hat{\gv{d}_3} \) (coordinates wrt
     natural bases). Then
   \[{\begin{bmatrix} x_{\mathcal{L}} \\ y_{\mathcal{L}} \\ z_{\mathcal{L}} \end{bmatrix}_{\mathcal{D}}} =
	 \underbrace{\begin{bmatrix}
	 \mbox{------}~\hat{\gv{d}}_1~\mbox{------} \\
	 \mbox{------}~\hat{\gv{d}}_2~\mbox{------} \\
	 \mbox{------}~\hat{\gv{d}}_3~\mbox{------} \\
	 \end{bmatrix}}_{\bv{Q}}
	 {\begin{bmatrix} x \\ y \\ z \end{bmatrix}_{\mathcal{E}}}
   \]
** Generalizing frame rotations as a basis change
   Taking it one step further we arrive at the conclusion,
  \[
	\underbrace{\begin{bmatrix}
	\mbox{|} & \mbox{|}& \mbox{|}\\
	\hat{\gv{d}_1} & \hat{\gv{d}_2} & \hat{\gv{d}_3} \\
	\mbox{|} & \mbox{|}& \mbox{|}\\
	\end{bmatrix}}_{\bv{Q}^{-1} = \bv{Q}^T}
	{\begin{bmatrix} x_{\mathcal{L}} \\ y_{\mathcal{L}} \\ z_{\mathcal{L}}
	\end{bmatrix}}
	=
	{\begin{bmatrix}1 & 0 & 0 \\ 0 & 1 & 0 \\0 & 0& 1\end{bmatrix}}
	{\begin{bmatrix} x \\ y \\ z \end{bmatrix}}
  \]

  \[
  \Rightarrow x_{\mathcal{L}}\hat{\gv{d}_1} + y_{\mathcal{L}}\hat{\gv{d}_2} +
  z_{\mathcal{L}}\hat{\gv{d}_3} = x\hat{i} + y\hat{j} + z\hat{k} = \gv{x} !
  \]
** Implementation of rotation as bases change
   - We have seen that the action of frame rotation matrices correspond to a
     bases change operation
   - Let's implement these operations in our framework
	 \[ R_{x}(\theta)={\begin{bmatrix}1&0&0\\0&\cos \theta &\sin \theta
     \\0&-\sin \theta &\cos \theta \\\end{bmatrix}}\]

	 \[ R_{y}(\theta)={\begin{bmatrix}\cos \theta & 0 & -\sin \theta\\
	 0&1&0 \\ \sin\theta & 0 & \cos \theta \\\end{bmatrix}} \]

	 \[R_{z}(\theta)={\begin{bmatrix}\cos \theta &\sin \theta &0\\-\sin
	 \theta &\cos\theta &0\\0&0&1\\\end{bmatrix}} \]
   - *DEMO*
** But what about arbitrary rotations?
	- Rotations about arbitrary axes with arbitrary angles?
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.6
	:END:
	 - Can we do compositions?
	   - *Yes*, but not that intutive (means of rotation, intrinsic/extrinsic)
	   - Not commutative (order matters) usually
***                                                                :B_column:
	:PROPERTIES:
	:BEAMER_env: column
	:BEAMER_col: 0.3
	:END:
	 #+ATTR_LATEX: :width 0.80\textwidth
	 file:images/rotated_cube.jpeg
***                                                         :B_ignoreheading:
	:PROPERTIES:
	:BEAMER_env: ignoreheading
	:END:
	 - Becomes even more complicated when we have frames depending on one another
	   - But not a bad idea---robotics[fn:3]
	 - *Idea*: If we know the linear bases transformation, we don't need to worry
       about compositions etc.
***                                                                  :B_note:
	:PROPERTIES:
	:BEAMER_env: note
	:END:
	- Mention that some means of rotation like quarternions are better suited,
      but require more math and understanding.
** Let's reconsider what we know
   - We know why \(  \gv{x}_{\mathcal{L}} = \bv{Q}\gv{x} \)
   - But...
	 - Do we know \( \bv{Q} \) ?
	   - We need the basis \( \hat{\gv{d}}_j \)
	 - Do we know \( \hat{\gv{d}}_j \)?
	   - *No*
   - We seek ways to obtain this basis \( \gv{d} \).
   - We will see that we require some properties on \( \gv{d} \) to make \(
     \bv{Q} \) effect a rotation.
** Obtaining \( \gv{d} \) : Options
   -
** TODO Rotations about fixed axis : Euler angles
** TODO Rotation using Euler angles : Implementation
** TODO Rotations using Euler angles: compositions
   - Show Rz * Ry * Rx
   - Put formula for the same here
   -
** TODO Rotations using Euler angles: compositions contd.
   - Is it commutative (does the order matter)
- Extrinsic or Intrinsic
** TODO Drawbacks of only using Euler-angle based rotation
   Not as intutive as only one axes. Althogugh it is possible.
** TODO Other options
**
**

* Footnotes

[fn:3] [[https://www.mecademic.com/resources/Euler-angles/Euler-angles][Mecademic Euler rotations]]

[fn:2][[https://iopscience.iop.org/book/978-0-7503-1454-1][Rotation, Reflection, and Frame Changes---Orthogonal tensors in computational engineering mechanics, RM Brannon, IOP Publishing 2018]]

[fn:1] All examples from Wikipedia found in [[https://en.wikipedia.org/wiki/Affine_transformation#Image_transformation][article "Affine transformation"
under section "Image transformation"]] and assume origin at the center of image
